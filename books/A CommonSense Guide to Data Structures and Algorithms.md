# A CommonSense Guide to Data Structures and Algorithms
- milk in the bowl. Dip a spoon
- Another way of explaining log2 8 is: if we kept dividing 8 by 2 until we ended up with 1, how many 2s would we have in our equation? 8 / 2 / 2 / 2 = 1 In other words, how many times do we need to divide 8 by 2 until we end up with 1? In this example, it takes us 3 times. Therefore, log2 8 = 3.
- In this second implementation, we use a while loop to skip over each element, rather than check each one. It turns out that for N elements, there are N / 2 lookups and N / 2 insertions into the new array. Like the first implementation, we’d say that the algorithm is O(N). However, our first implementation truly takes 1.5N steps, while our second implementation only takes N steps, making our second implementation significantly faster. While the first implementation is more idiomatic in the way Ruby programmers write their code, if we’re dealing with large amounts of data, it’s worth considering using the second implementation to get a significant performance boost.
- Interestingly, in the case of infinite recursion (such as the very first example in our chapter), the program keeps on pushing the same method over and over again onto the call stack, until there’s no more room in the computer’s memory—and this causes an error known as stack overflow.
- One case where linked lists shine is when we examine a single list and delete many elements from
