# Practices of the Python Pro MEAP V07
- Database behavior is repetitive and mixed with user interaction 
- You learned earlier that composition provides benefits over inheritance by allowing objects to reuse behaviors without confining them to a particular inheritance hierarchy. When you separate your concerns into many smaller classes and want to compose those behaviors back together, you can write a class that uses instances of those smaller classes.
- “is-an” A. This is to stress that instances of B are in fact instances of A, and as such should look like an A (more on this in a bit). Contrast this with composition, where if an instance of class  C uses an instance of a class D, we say that C “has-a” D to emphasize that C is composed of D (among other things, potentially).
- When a class B inherits from a class A, we often say B “is-an” A. This is to stress that instances of B are in fact instances of A, and as such should look like an A (more on this in a bit). Contrast this with composition, where if an instance of class  C uses an instance of a class D, we say that C “has-a” D to emphasize that C is composed of D (among other things, potentially).
- Because a tire isn’t composed of a bike (it’s the other way around), A is incorrect, whereas B makes sense—that’s composition. And because a carbon fiber frame is a frame (it doesn’t have a frame), D is also incorrect, whereas C makes sense—that’s inheritance. Again, inheritance is for specialization, whereas composition is for reusable behaviors (figure 8.3).
- Halstead complexity For some applications, reducing the risk of shipping defective software is as big a priority as maintainability. Although reducing branches in your code tends to make it more readable and understandable, it hasn’t been proven to reduce the number of bugs in software. Cyclomatic complexity predicts the number of defects about as well as the number of lines of code does. But there’s at least one set of metrics out there that tries to address the defect rate. Halstead complexity attempts to measure quantitatively the ideas of level of abstraction, maintainability, and defect rate. Measuring Halstead complexity involves inspecting a program’s use of the programming language’s built-in operators and how many variables and expressions it contains. It’s beyond the scope of this book, but I recommend reading more about it (the Wikipedia article is a good place to start: en.wikipedia.org/wiki/Halstead_complexity_measures). Radon (radon.readthedocs.io) can measure the Halstead complexity of your Python programs if you’re interested in exploring.
- Fortunately you won’t need to diagram each function and method you write. A number of tools out there, like SonarQube (www.sonarqube.org/) and Radon (radon.readthedocs.io), can measure these for you. These tools can even be integrated into your development tools so that you can break up complex code as you develop.
- Now that you’ve learned some of the ways to discover when code has grown complex, you’ll can get some practice breaking down that complexity.
- Believe it or not, this new solution is reduced back to a cyclomatic complexity of 1. And even if you continue adding entries to the formats dictionary, no additional complexity is added. This is the kind of gain I talked about in chapter 4; you’ve gone from a linear algorithm to a constant one.
- You may be thinking this code is more complex; you now have four functions compared to your initial one. But you’ve achieved something here: each of these functions has a cyclomatic complexity
- You may be thinking this code is more complex; you now have four functions compared to your initial one. But you’ve achieved something here: each of these functions has a cyclomatic complexity of 1, is quite readable, and has a nice separation of concerns.
- You’ve also got something extensible on your hands, because when you need to handle new response formats, the process is as follows: Add a new function to format the response as desired. Add the mapping of the required Accept header value to the new formatting function. Profit. You can create new business value just by adding new code and updating configuration. This is the ideal.
- I’ve talked about extracting functions and methods as a useful way to break down code. One approach you could take here is to extract the logic for display_title into a set_display_title method that you could call from the __init__ method, as shown in the following listing. Try creating a book module and adding the Book class to
- I’ve talked about extracting functions and methods as a useful way to break down code. One approach you could take here is to extract the logic for display_title into a set_display_title method that you could call from the __init__ method, as shown in the following listing. Try creating a book module and adding the Book class to it, extracting a setter method for display_title. Listing 9.7. Using a setter to simplify class construction
- I’ve talked about extracting functions and methods as a useful way to break down code. One approach you could take here is to extract the logic for display_title into a set_display_title method that you could call from the __init__ method, as shown in the following listing. Try creating a book module and adding the Book class to it, extracting a setter method for display_title.
- Getters and setters are generally discouraged in Python because they can clutter up
- Create a display_title method now, decorated with @property, that uses the existing logic to return the proper display title. Compare your changes with the following listing when you’re done.
- Methods can be used as properties only if  self is their only argument, because when you access the attribute you can’t pass any arguments to
- Methods can be used as properties only if  self is their only argument, because when you access the attribute you can’t pass any arguments to it.
- The @property decorator can be used to signify that a method on a class should be accessible as an attribute.
- Using @property, you can still reference book.display_title as an attribute, but all its complexity is abstracted into its own function. This reduces the complexity of the __init__ method, making it more readable at the same time. I make frequent use of @property in my own code.
- [20] See Brett Slatkin, “Refactoring Python: Why and how to restructure your code,” PyCon 2016, www.youtube.com/watch?v=D_6ybDcU5gc,
- inherently bad in all cases. Rather, it focuses on the ways tight and loose coupling differ and helps you get a sense of the resulting outcomes for your code—tight coupling usually means more work when you want to shuffle things around. It also implies that coupling is a continuum rather than a binary, all-or-nothing thing.
- class that stores another object as an attribute
- your code, several things create interconnections: A class that stores another object as an attribute A class whose methods call functions from another module A function or method that does a lot of procedural work using methods from another object
- Some tight coupling is a sign of high cohesion that isn’t structured well.
- resourcefulness is more valuable than experience.
